{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-05662b5f63970d7a9af5efdde91e7a8c8325bd14",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/DataUrlHook.sol": "project/contracts/DataUrlHook.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@ensdomains/ens-contracts/=npm/@ensdomains/ens-contracts@1.5.2/",
        "project/:@ensdomains/ens-contracts/=npm/@ensdomains/ens-contracts@1.5.2/",
        "project/:@ensdomains/ens-contracts/=npm/@ensdomains/ens-contracts@1.5.2/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@4.9.6/"
      ]
    },
    "sources": {
      "npm/@ensdomains/ens-contracts@1.5.2/contracts/resolvers/profiles/IExtendedResolver.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IExtendedResolver {\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}\n"
      },
      "npm/@ensdomains/ens-contracts@1.5.2/contracts/resolvers/profiles/ITextResolver.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ITextResolver {\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /// Returns the text data associated with an ENS node and key.\n    /// @param node The ENS node to query.\n    /// @param key The text data key to query.\n    /// @return The associated text data.\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}\n"
      },
      "npm/@ensdomains/ens-contracts@1.5.2/contracts/utils/BytesUtils.sol": {
        "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nlibrary BytesUtils {\n    error OffsetOutOfBoundsError(uint256 offset, uint256 length);\n\n    /// @dev Returns the keccak-256 hash of a byte range.\n    /// @param self The byte string to hash.\n    /// @param offset The position to start hashing at.\n    /// @param len The number of bytes to hash.\n    /// @return ret The hash of the byte range.\n    function keccak(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(offset + len <= self.length);\n        assembly {\n            ret := keccak256(add(add(self, 32), offset), len)\n        }\n    }\n\n    /// @dev Returns a positive number if `other` comes lexicographically after\n    ///      `self`, a negative number if it comes before, or zero if the\n    ///      contents of the two bytes are equal.\n    /// @param self The first bytes to compare.\n    /// @param other The second bytes to compare.\n    /// @return The result of the comparison.\n    function compare(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (int256) {\n        return compare(self, 0, self.length, other, 0, other.length);\n    }\n\n    /// @dev Returns a positive number if `other` comes lexicographically after\n    ///      `self`, a negative number if it comes before, or zero if the\n    ///      contents of the two bytes are equal. Comparison is done per-rune,\n    ///      on unicode codepoints.\n    /// @param self The first bytes to compare.\n    /// @param offset The offset of self.\n    /// @param len    The length of self.\n    /// @param other The second bytes to compare.\n    /// @param otheroffset The offset of the other string.\n    /// @param otherlen    The length of the other string.\n    /// @return The result of the comparison.\n    function compare(\n        bytes memory self,\n        uint256 offset,\n        uint256 len,\n        bytes memory other,\n        uint256 otheroffset,\n        uint256 otherlen\n    ) internal pure returns (int256) {\n        if (offset + len > self.length) {\n            revert OffsetOutOfBoundsError(offset + len, self.length);\n        }\n        if (otheroffset + otherlen > other.length) {\n            revert OffsetOutOfBoundsError(otheroffset + otherlen, other.length);\n        }\n\n        uint256 shortest = len;\n        if (otherlen < len) shortest = otherlen;\n\n        uint256 selfptr;\n        uint256 otherptr;\n\n        assembly {\n            selfptr := add(self, add(offset, 32))\n            otherptr := add(other, add(otheroffset, 32))\n        }\n        for (uint256 idx = 0; idx < shortest; idx += 32) {\n            uint256 a;\n            uint256 b;\n            assembly {\n                a := mload(selfptr)\n                b := mload(otherptr)\n            }\n            if (a != b) {\n                uint256 rest = shortest - idx;\n                if (rest < 32) {\n                    // shift out the irrelevant bits\n                    rest = (32 - rest) << 3; // bits to drop\n                    a >>= rest;\n                    b >>= rest;\n                }\n                if (a < b) {\n                    return -1;\n                } else if (a > b) {\n                    return 1;\n                }\n            }\n            selfptr += 32;\n            otherptr += 32;\n        }\n\n        return int256(len) - int256(otherlen);\n    }\n\n    /// @dev Returns true if the two byte ranges are equal.\n    /// @param self The first byte range to compare.\n    /// @param offset The offset into the first byte range.\n    /// @param other The second byte range to compare.\n    /// @param otherOffset The offset into the second byte range.\n    /// @param len The number of bytes to compare\n    /// @return True if the byte ranges are equal, false otherwise.\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset,\n        uint256 len\n    ) internal pure returns (bool) {\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\n    }\n\n    /// @dev Returns true if the two byte ranges are equal with offsets.\n    /// @param self The first byte range to compare.\n    /// @param offset The offset into the first byte range.\n    /// @param other The second byte range to compare.\n    /// @param otherOffset The offset into the second byte range.\n    /// @return True if the byte ranges are equal, false otherwise.\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other,\n        uint256 otherOffset\n    ) internal pure returns (bool) {\n        return\n            keccak(self, offset, self.length - offset) ==\n            keccak(other, otherOffset, other.length - otherOffset);\n    }\n\n    /// @dev Compares a range of 'self' to all of 'other' and returns True iff\n    ///      they are equal.\n    /// @param self The first byte range to compare.\n    /// @param offset The offset into the first byte range.\n    /// @param other The second byte range to compare.\n    /// @return True if the byte ranges are equal, false otherwise.\n    function equals(\n        bytes memory self,\n        uint256 offset,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == offset + other.length &&\n            equals(self, offset, other, 0, other.length);\n    }\n\n    /// @dev Returns true if the two byte ranges are equal.\n    /// @param self The first byte range to compare.\n    /// @param other The second byte range to compare.\n    /// @return True if the byte ranges are equal, false otherwise.\n    function equals(\n        bytes memory self,\n        bytes memory other\n    ) internal pure returns (bool) {\n        return\n            self.length == other.length &&\n            equals(self, 0, other, 0, self.length);\n    }\n\n    /// @dev Returns the 8-bit number at the specified index of self.\n    /// @param self The byte string.\n    /// @param idx The index into the bytes\n    /// @return ret The specified 8 bits of the string, interpreted as an integer.\n    function readUint8(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint8 ret) {\n        return uint8(self[idx]);\n    }\n\n    /// @dev Returns the 16-bit number at the specified index of self.\n    /// @param self The byte string.\n    /// @param idx The index into the bytes\n    /// @return ret The specified 16 bits of the string, interpreted as an integer.\n    function readUint16(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint16 ret) {\n        require(idx + 2 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\n        }\n    }\n\n    /// @dev Returns the 32-bit number at the specified index of self.\n    /// @param self The byte string.\n    /// @param idx The index into the bytes\n    /// @return ret The specified 32 bits of the string, interpreted as an integer.\n    function readUint32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (uint32 ret) {\n        require(idx + 4 <= self.length);\n        assembly {\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\n        }\n    }\n\n    /// @dev Returns the 32 byte value at the specified index of self.\n    /// @param self The byte string.\n    /// @param idx The index into the bytes\n    /// @return ret The specified 32 bytes of the string.\n    function readBytes32(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes32 ret) {\n        require(idx + 32 <= self.length);\n        assembly {\n            ret := mload(add(add(self, 32), idx))\n        }\n    }\n\n    /// @dev Returns the 32 byte value at the specified index of self.\n    /// @param self The byte string.\n    /// @param idx The index into the bytes\n    /// @return ret The specified 32 bytes of the string.\n    function readBytes20(\n        bytes memory self,\n        uint256 idx\n    ) internal pure returns (bytes20 ret) {\n        require(idx + 20 <= self.length);\n        assembly {\n            ret := and(\n                mload(add(add(self, 32), idx)),\n                0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000\n            )\n        }\n    }\n\n    /// @dev Returns the n byte value at the specified index of self.\n    /// @param self The byte string.\n    /// @param idx The index into the bytes.\n    /// @param len The number of bytes.\n    /// @return ret The specified 32 bytes of the string.\n    function readBytesN(\n        bytes memory self,\n        uint256 idx,\n        uint256 len\n    ) internal pure returns (bytes32 ret) {\n        require(len <= 32);\n        require(idx + len <= self.length);\n        assembly {\n            let mask := not(sub(exp(256, sub(32, len)), 1))\n            ret := and(mload(add(add(self, 32), idx)), mask)\n        }\n    }\n\n    function memcpy(uint256 dest, uint256 src, uint256 len) private pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint256 mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n    }\n\n    /// @dev Copies a substring into a new byte string.\n    /// @param self The byte string to copy from.\n    /// @param offset The offset to start copying at.\n    /// @param len The number of bytes to copy.\n    function substring(\n        bytes memory self,\n        uint256 offset,\n        uint256 len\n    ) internal pure returns (bytes memory) {\n        require(offset + len <= self.length);\n\n        bytes memory ret = new bytes(len);\n        uint256 dest;\n        uint256 src;\n\n        assembly {\n            dest := add(ret, 32)\n            src := add(add(self, 32), offset)\n        }\n        memcpy(dest, src, len);\n\n        return ret;\n    }\n\n    // Maps characters from 0x30 to 0x7A to their base32 values.\n    // 0xFF represents invalid characters in that range.\n    bytes constant base32HexTable =\n        hex\"00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F\";\n\n    /// @dev Decodes unpadded base32 data of up to one word in length.\n    /// @param self The data to decode.\n    /// @param off Offset into the string to start at.\n    /// @param len Number of characters to decode.\n    /// @return The decoded data, left aligned.\n    function base32HexDecodeWord(\n        bytes memory self,\n        uint256 off,\n        uint256 len\n    ) internal pure returns (bytes32) {\n        require(len <= 52);\n\n        uint256 ret = 0;\n        uint8 decoded;\n        for (uint256 i = 0; i < len; i++) {\n            bytes1 char = self[off + i];\n            require(char >= 0x30 && char <= 0x7A);\n            decoded = uint8(base32HexTable[uint256(uint8(char)) - 0x30]);\n            require(decoded <= 0x20);\n            if (i == len - 1) {\n                break;\n            }\n            ret = (ret << 5) | decoded;\n        }\n\n        uint256 bitlen = len * 5;\n        if (len % 8 == 0) {\n            // Multiple of 8 characters, no padding\n            ret = (ret << 5) | decoded;\n        } else if (len % 8 == 2) {\n            // Two extra characters - 1 byte\n            ret = (ret << 3) | (decoded >> 2);\n            bitlen -= 2;\n        } else if (len % 8 == 4) {\n            // Four extra characters - 2 bytes\n            ret = (ret << 1) | (decoded >> 4);\n            bitlen -= 4;\n        } else if (len % 8 == 5) {\n            // Five extra characters - 3 bytes\n            ret = (ret << 4) | (decoded >> 1);\n            bitlen -= 1;\n        } else if (len % 8 == 7) {\n            // Seven extra characters - 4 bytes\n            ret = (ret << 2) | (decoded >> 3);\n            bitlen -= 3;\n        } else {\n            revert();\n        }\n\n        return bytes32(ret << (256 - bitlen));\n    }\n\n    /// @dev Finds the first occurrence of the byte `needle` in `self`.\n    /// @param self The string to search\n    /// @param off The offset to start searching at\n    /// @param len The number of bytes to search\n    /// @param needle The byte to search for\n    /// @return The offset of `needle` in `self`, or 2**256-1 if it was not found.\n    function find(\n        bytes memory self,\n        uint256 off,\n        uint256 len,\n        bytes1 needle\n    ) internal pure returns (uint256) {\n        for (uint256 idx = off; idx < off + len; idx++) {\n            if (self[idx] == needle) {\n                return idx;\n            }\n        }\n        return type(uint256).max;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@4.9.6/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/DataUrlHook.sol": {
        "content": "pragma solidity ^0.8.28;\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/IExtendedResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\";\nimport \"@ensdomains/ens-contracts/contracts/utils/BytesUtils.sol\";\nimport \"./IDataUrlHook.sol\";\n\ncontract DataUrlHook is Ownable, ERC165, IExtendedResolver {\n    using BytesUtils for bytes;\n    mapping(bytes32 => string) dataUrls;\n\n    //a cache control nonce is a unique ID that can be used to invalidate a cache serving this data as static content\n    //when the nonce has not changed, it is considered safe to not invalidate the cache of the service serving this data\n    //no change: content may be refetched at any time, but is assumed unchanged\n    //change: content must be considered invalid, but may be subject to service's minimum cache time\n    //programmatic change (i.e. nonce = block.timestamp): cache will always be considered stale, subject to service's minimum caching time\n    mapping(bytes32 => uint256) cacheControlNonce;\n\n    function resolve(\n        bytes memory _name,\n        bytes calldata data\n    ) external view returns (bytes memory) {\n        require(bytes4(data[0:4]) == IDataUrlHook.hook.selector,\n            \"Method not supported\"\n        );\n        (bytes32 node, string memory key, address resolver, uint256 coinType) = abi.decode(data[4:], (bytes32, string, address, uint256));\n        require(resolver == address(this), \"Wrong resolver\");\n        //TODO: cointype check? do we care?\n        bytes memory keyBytes = bytes(key);\n        uint256 suffixLength = bytes(\":dataURL\").length;\n        require(keyBytes.length >= suffixLength, \"Invalid key\");\n        require(keyBytes.equals(keyBytes.length - suffixLength, bytes(\":dataURL\")), \"Invalid key\");\n        return bytes(dataUrls[node]);\n    }\n\n    function setDataURL(bytes32 node, bool updateNonce, string calldata dataUrl) public onlyOwner {\n        if(updateNonce) {\n            cacheControlNonce[node] = block.timestamp;\n        }\n        dataUrls[node] = dataUrl;\n    }\n\n    function setCacheControlNonce(bytes32 node, uint256 nonce) public onlyOwner {\n        cacheControlNonce[node] = nonce;\n    }\n\n    function getCacheControlNonce(bytes32 node) public view returns (uint256) {\n        return cacheControlNonce[node];\n    }\n\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view virtual override returns (bool) {\n        return interfaceID == 0x9061b923 || super.supportsInterface(interfaceID);\n    }\n}"
      },
      "project/contracts/IDataUrlHook.sol": {
        "content": "pragma solidity ^0.8.28;\ninterface IDataUrlHook {\n    function hook(bytes32 node, string calldata key, address resolver, uint256 coinType) external returns (string memory);\n}"
      }
    }
  }
}